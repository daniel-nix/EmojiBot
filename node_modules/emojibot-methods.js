module.exports = {
    parseMessage: parseMessage
}

const Discord = require('discord.js');
const fs = require('fs');
const readline = require('readline');
const fileReplace = require('replace-in-file');

// commands //
const ADD_EMOJI = 'addemoji'
const REMOVE_EMOJI = 'removeemoji'
const LIST_EMOJIS = 'list'
const FILE_NAME = 'emoji_list.txt'

// accepted embedded options //
const BROKEN_GIF = '--brokengif'
const VIDEO = '--video'
const EMBED_OPTIONS = '(\\.png)|(\\.jpg)|(\\.jpeg)|(\\.gif)(?!v)|(\\.tiff)|(\\.bmp)';

function parseMessage(message) {
    var messageContent = message.content.trim();
    if(messageContent.charAt(0) == '~') {
        var tokens = messageContent.slice(1, messageContent.length).split(" ");
        switch(tokens[0].toLowerCase()) {
            case ADD_EMOJI:
                addEmoji(message);
                break;
            case REMOVE_EMOJI:
                removeEmoji(message);
                break;
            case LIST_EMOJIS:
                listEmojis(message);
                break;
            default:
                sendAndReplaceEmoji(message);
                break;
        }
        
    }
}

function addEmoji(message) {
    var messageAttachments = findAttachmentsFromMessage(message)
    var options = retreiveOptions(message.content);

    for(var emojiName in messageAttachments) {
        fs.appendFile(FILE_NAME, `${emojiName} ${canEmbed(options)} => ${messageAttachments[emojiName]}\n`, function(err) {
            if(err) throw err;

            message.channel.send('Emoji saved!');
        });
    }
}

function findAttachmentsFromMessage(message) {
    var attachments = message.attachments;
    var contentTokens = message.content.trim().split(" ");
    contentTokens.shift();
    var attachmentURLs = [];
    if(attachments.size != 0) {
        var emojiNameIndex = 0;
        for(var [key, messageAttachment] of attachments) {
            if(emojiNameIndex > contentTokens.length) break;

            attachmentURLs[contentTokens[emojiNameIndex]] = messageAttachment.url;
        }
    } else {
        //check if the URL is in the message content
        for(var i = 0; i <= contentTokens.length-2; i++) {
            attachmentURLs[contentTokens[i]] = contentTokens[i+1];
        }
    }
    return attachmentURLs;
}

function retreiveOptions(messageContent) {
    const regex = new RegExp(EMBED_OPTIONS, 'g');
    var options = regex.exec(messageContent);
    return options;
}

function canEmbed(options) {
    return options != null ? 'true' : '';
}

function removeEmoji(message) {
    var emojiName = findEmojiName(message);

    const regex = new RegExp(`${emojiName}.*`);
    const options = {
        files: FILE_NAME,

        from:regex,
        to: ""
    };
    fileReplace(options)
        .then(() => {
            message.channel.send('Emoji removed!');
            message.delete();
        })
        .catch(err => {
            throw err;
        });
}

function findEmojiName(message) {
    var messageContent = message.content.trim().split(" ");
    messageContent.shift();
    return messageContent[0];
}

async function listEmojis(message) {
    var readStream = fs.createReadStream(FILE_NAME)
    var attachment = null;
    const readInterface = readline.createInterface({
        input: readStream
    });

    
    const getLine = (function () {
        const getLineGen = (async function* () {
            for await (const line of readInterface) {
                yield line;
            }
        })();
        return async () => ((await getLineGen.next()).value);
    })();

    var lines = "";
    var line;
    while((line = await getLine()) !== undefined) {
        if(line !== '') {
            lines += line.split(" => ")[0].split(' ')[0] + "\n";
        }
    }

    message.channel.send(lines);
}

async function sendAndReplaceEmoji(message) {
    var emojiName = message.content.trim().split('~')[1];

    if(emojiName != null) {
        var attachment = await searchForEmoji(emojiName);
        if(Object.keys(attachment).length != 0) {
            if(attachment['options'] != '')
                sendEmbeddedEmoji(message, attachment);
            else
                sendNormalMessage(message, attachment);
            message.delete();
        }
    }
}

async function searchForEmoji(emojiName) {
    var readStream = fs.createReadStream(FILE_NAME)
    var attachment = [];
    const readInterface = readline.createInterface({
        input: readStream
    });

    
    const getLine = (function () {
        const getLineGen = (async function* () {
            for await (const line of readInterface) {
                yield line;
            }
        })();
        return async () => ((await getLineGen.next()).value);
    })();

    var line;
    while(1) {
        line = await getLine();
        if(line !== '' && line.includes(emojiName)) {
            var lineTokens = line.split(' => ');
            var nameAndEmbed = lineTokens[0].split(' ');
            attachment['emoji'] = lineTokens[1];
            attachment['emoji_name'] = '~' + nameAndEmbed[0];
            attachment['options'] = nameAndEmbed[1];
            break;
        }
    }
    return attachment;
}

function sendNormalMessage(message, attachment) {
    message.channel.send(`${attachment['emoji']} \`\`\`${attachment['emoji_name']} Sent by: ${message.author.username}\`\`\``);
}

function sendEmbeddedEmoji(message, attachment) {
    const emojiEmbed = new Discord.RichEmbed()
        .setFooter(`${attachment['emoji_name']} Sent by: ${message.author.username}`)
        .setImage(attachment['emoji']);
    message.channel.send(emojiEmbed);
}